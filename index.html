<!DOCTYPE html>
<html>
<head>
    <title>BC Traffic Map with Elevation & Axis Labels</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1.0" />
    <!-- Replace YOUR_API_KEY with your actual API key that has Elevation API enabled -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCIzypwXHVm4201GULNbcXz3L1fMPEaouE"></script>
</head>
<body>

<h1>BC Traffic Map</h1>
<div id="map" style="width:100%; height:600px;"></div>

<h1>Select an Area</h1>
<select id="areasDropdown">
    <option value="">-- Choose an Area --</option>
</select>

<script>
    let map;
    let elevationService;

    // Predefined area centers for BC (from Open511)
    const areaCenters = {
        "drivebc.ca/1":  { lat: 49.2058, lng: -123.0233 },
        "drivebc.ca/2":  { lat: 48.4611, lng: -123.3787 },
        "drivebc.ca/3":  { lat: 50.5074, lng: -116.0311 },
        "drivebc.ca/4":  { lat: 49.3297, lng: -116.7014 },
        "drivebc.ca/5":  { lat: 51.0002, lng: -118.1955 },
        "drivebc.ca/6":  { lat: 50.6718, lng: -120.3241 },
        "drivebc.ca/7":  { lat: 52.9809, lng: -122.4933 },
        "drivebc.ca/8":  { lat: 55.7579, lng: -120.2373 },
        "drivebc.ca/9":  { lat: 53.9101, lng: -122.7617 },
        "drivebc.ca/10": { lat: 54.7814, lng: -127.1661 },
        "drivebc.ca/11": { lat: 54.0552, lng: -128.6526 }
    };

    function initMap() {
        map = new google.maps.Map(document.getElementById("map"), {
            center: { lat: 49.2827, lng: -123.1207 },
            zoom: 6
        });

        // Elevation service for slope calculations
        elevationService = new google.maps.ElevationService();

        // Load multiple GeoJSON files
        // 1) Some roads
        loadRoadPolylines("map.geojson");
        // 2) More roads
        loadRoadPolylines("westbay_cypress.geojson");
        // 3) OSM roads from Overpass, with extra tags (cycleway, sidewalk, etc.)
        loadRoadPolylines("burnaby_bsss.geojson");

        // Load events (Open511)
        loadEventsWithIcons();
    }

    window.onload = initMap;

    // Fetch areas from Open511
    fetch("https://api.open511.gov.bc.ca/areas?format=json")
        .then(r => r.json())
        .then(data => {
            const areas = data.areas;
            const dropdown = document.getElementById("areasDropdown");
            areas.forEach(a => {
                const opt = document.createElement("option");
                opt.value = a.id;
                opt.textContent = a.name;
                dropdown.appendChild(opt);
            });
        })
        .catch(err => console.error("Error fetching areas:", err));

    document.getElementById("areasDropdown").addEventListener("change", e => {
        const selectedId = e.target.value;
        const coords = areaCenters[selectedId];
        if (coords) {
            map.setCenter(coords);
            map.setZoom(12);
        }
    });

    // Load road data from a local GeoJSON file
    function loadRoadPolylines(file) {
        fetch(file)
            .then(r => r.json())
            .then(geo => {
                // Filter for features that have a 'highway' tag, if needed
                const roadFeatures = geo.features.filter(f => f.properties && f.properties.highway);

                roadFeatures.forEach(feature => {
                    const props = feature.properties || {};
                    const geom  = feature.geometry;

                    // Basic fields
                    const roadName     = props.name || "(Unnamed Road)";
                    const roadLengthKm = calculateLineLength(geom);

                    // Additional OSM tags (if present)
                    const cycleway = props.cycleway  || "None";
                    const sidewalk = props.sidewalk  || "Unknown";
                    const surface  = props.surface   || "N/A";
                    const maxspeed = props.maxspeed  || "N/A";

                    if (geom.type === "LineString") {
                        drawPolyline(geom.coordinates, {
                            name: roadName,
                            lengthKm: roadLengthKm,
                            cycleway,
                            sidewalk,
                            surface,
                            maxspeed
                        });
                    } else if (geom.type === "MultiLineString") {
                        geom.coordinates.forEach(line => {
                            drawPolyline(line, {
                                name: roadName,
                                lengthKm: roadLengthKm,
                                cycleway,
                                sidewalk,
                                surface,
                                maxspeed
                            });
                        });
                    }
                });
            })
            .catch(err => console.error("Error loading", file, err));
    }

    // Create a Polyline and store relevant road data on it
    function drawPolyline(coordsArray, roadInfo) {
        const pathLatLng = coordsArray.map(c => ({ lat: c[1], lng: c[0] }));
        const polyline = new google.maps.Polyline({
            path: pathLatLng,
            strokeColor: "#0000FF",
            strokeWeight: 2,
            map
        });

        // Attach your data so we can display it later
        polyline.roadName   = roadInfo.name;
        polyline.roadLength = roadInfo.lengthKm;
        polyline.pathLatLng = pathLatLng;
        polyline.cycleway   = roadInfo.cycleway;
        polyline.sidewalk   = roadInfo.sidewalk;
        polyline.surface    = roadInfo.surface;
        polyline.maxspeed   = roadInfo.maxspeed;

        // On click, highlight the road and show slope + OSM tags
        polyline.addListener("click", (e) => {
            // highlight in red
            polyline.setOptions({ strokeColor: "#FF0000", strokeWeight: 4 });
            getElevationAndShowInfo(polyline, e.latLng);
        });
    }

    // Query ElevationService for slope data
    function getElevationAndShowInfo(polyline, clickLocation) {
        const pathRequest = {
            path: polyline.pathLatLng,
            samples: 50
        };
        elevationService.getElevationAlongPath(pathRequest, (results, status) => {
            if (status === "OK" && results && results.length > 1) {
                const elevStart = results[0].elevation;
                const elevEnd   = results[results.length - 1].elevation;
                const slopePercent = computeSlopePercent(polyline.pathLatLng, elevStart, elevEnd);

                const elevations = results.map(r => r.elevation);
                showRoadInfoWithElevation(polyline, clickLocation, elevations, slopePercent);
            } else {
                console.warn("ElevationService failed:", status);
                showRoadInfoWithElevation(polyline, clickLocation, null, null);
            }
        });
    }

    // slope = (end_elev - start_elev)/(distance in m)*100%
    function computeSlopePercent(pathLatLng, elevStart, elevEnd) {
        const latLng1 = pathLatLng[0];
        const latLng2 = pathLatLng[pathLatLng.length - 1];
        const distKm  = haversineDistance(latLng1.lat, latLng1.lng, latLng2.lat, latLng2.lng);
        const distM   = distKm * 1000;
        const elevChange = elevEnd - elevStart;
        return (elevChange / distM) * 100;
    }

    // Build and display an InfoWindow with road info, OSM tags, slope, chart
    function showRoadInfoWithElevation(polyline, clickLocation, elevationArray, slopePercent) {
        // Unique ID so multiple charts don't clash
        let uniqueId = "elevChart_" + Date.now() + "_" + Math.floor(Math.random() * 1000);

        let slopeText = slopePercent !== null
            ? slopePercent.toFixed(2) + "%"
            : "(No data)";

        const name     = polyline.roadName;
        const lengthKm = polyline.roadLength.toFixed(2);

        // Additional OSM tags
        const cycleway = polyline.cycleway;
        const sidewalk = polyline.sidewalk;
        const surface  = polyline.surface;
        const maxspeed = polyline.maxspeed;

        let content = `
          <div style="min-width:220px;">
            <p><strong>Road Name:</strong> ${name}</p>
            <p><strong>Length (approx):</strong> ${lengthKm} km</p>
            <p><strong>Slope (start-end):</strong> ${slopeText}</p>

            <hr/>
            <p><strong>Cycleway:</strong> ${cycleway}</p>
            <p><strong>Sidewalk:</strong> ${sidewalk}</p>
            <p><strong>Surface:</strong> ${surface}</p>
            <p><strong>Max Speed:</strong> ${maxspeed} km/h</p>
        `;

        // If we have elevation data, show a chart
        if (elevationArray) {
            content += `
              <p><strong>Elevation Profile:</strong></p>
              <canvas id="${uniqueId}" width="300" height="150" style="border:1px solid #ccc;"></canvas>
            `;
        }

        content += `</div>`;

        const infoWindow = new google.maps.InfoWindow({
            content,
            position: clickLocation
        });
        infoWindow.open({ map });

        // If we have elevation data, draw the chart once the DOM is ready
        if (elevationArray) {
            google.maps.event.addListenerOnce(infoWindow, "domready", () => {
                drawElevationChart(uniqueId, elevationArray, name);
            });
        }
    }

    // Basic line chart with axes, labeling "Start of X" / "End of X"
    function drawElevationChart(canvasId, elevations, roadName) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        const ctx = canvas.getContext("2d");
        const width  = canvas.width;
        const height = canvas.height;

        // Margins for axis
        const marginLeft   = 40;
        const marginRight  = 20;
        const marginTop    = 20;
        const marginBottom = 40;

        // Chart drawing region
        const chartWidth  = width  - marginLeft - marginRight;
        const chartHeight = height - marginTop  - marginBottom;

        // Data stats
        const minElev = Math.min(...elevations);
        const maxElev = Math.max(...elevations);
        const range   = (maxElev - minElev) || 1;

        ctx.clearRect(0, 0, width, height);

        // 1) Draw axes
        ctx.beginPath();
        // Y-axis
        ctx.moveTo(marginLeft, marginTop);
        ctx.lineTo(marginLeft, marginTop + chartHeight);
        // X-axis
        ctx.lineTo(marginLeft + chartWidth, marginTop + chartHeight);
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // 2) X-axis labels
        ctx.font = "12px Arial";
        ctx.textAlign = "left";
        ctx.fillText("Start of", marginLeft, marginTop + chartHeight + 15);
        ctx.fillText(roadName, marginLeft, marginTop + chartHeight + 30);

        ctx.textAlign = "right";
        ctx.fillText("End of", marginLeft + chartWidth, marginTop + chartHeight + 15);
        ctx.fillText(roadName, marginLeft + chartWidth, marginTop + chartHeight + 30);

        // 3) Y-axis ticks (min, mid, max)
        const numTicks = 3;
        for (let i = 0; i <= numTicks; i++) {
            const value = minElev + (range * i / numTicks);
            const y = marginTop + chartHeight - ((value - minElev)/range)*chartHeight;

            ctx.beginPath();
            ctx.moveTo(marginLeft - 5, y);
            ctx.lineTo(marginLeft, y);
            ctx.stroke();

            ctx.textAlign = "right";
            ctx.fillText(value.toFixed(0) + "m", marginLeft - 8, y + 3);
        }

        // 4) Plot the line
        ctx.beginPath();
        elevations.forEach((elev, i) => {
            const xRatio = i / (elevations.length - 1);
            const x = marginLeft + (xRatio * chartWidth);

            const elevNorm = (elev - minElev) / range;
            const y = marginTop + chartHeight - (elevNorm * chartHeight);

            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.strokeStyle = "#FF0000";
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    // Calculate approximate length of geometry in km
    function calculateLineLength(geometry) {
        let totalKm = 0;
        if (geometry.type === "LineString") {
            totalKm = computeCoordsDistance(geometry.coordinates);
        } else if (geometry.type === "MultiLineString") {
            geometry.coordinates.forEach(lineCoords => {
                totalKm += computeCoordsDistance(lineCoords);
            });
        }
        return totalKm;
    }

    // Sum distances for consecutive coordinates
    function computeCoordsDistance(coords) {
        let dist = 0;
        for (let i = 0; i < coords.length - 1; i++) {
            const [lon1, lat1] = coords[i];
            const [lon2, lat2] = coords[i + 1];
            dist += haversineDistance(lat1, lon1, lat2, lon2);
        }
        return dist;
    }

    // Haversine formula for lat/lon in degrees, returns km
    function haversineDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Earth radius in km
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat/2)**2
            + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }

    function toRad(val){
        return (val * Math.PI) / 180;
    }

    // Load events from Open511, place markers for 3 event types
    function loadEventsWithIcons() {
        fetch("https://api.open511.gov.bc.ca/events?format=json&status=ACTIVE")
            .then(r => r.json())
            .then(data => {
                if (data.events) {
                    data.events.forEach(e => {
                        if(["CONSTRUCTION","SPECIAL_EVENT","INCIDENT"].includes(e.event_type)){
                            placeEventMarker(e);
                        }
                    });
                }
            })
            .catch(err => console.error("Error fetching events:", err));
    }

    function placeEventMarker(event) {
        if (!event.geography || event.geography.type !== "Point") return;
        const coords = event.geography.coordinates;
        if (!Array.isArray(coords) || coords.length < 2) return;

        const position = { lat: coords[1], lng: coords[0] };

        let iconUrl;
        switch(event.event_type){
            case "CONSTRUCTION":  iconUrl="images/construction.png"; break;
            case "SPECIAL_EVENT": iconUrl="images/special_event.png"; break;
            case "INCIDENT":      iconUrl="images/incident.png"; break;
            default: return;
        }

        const marker = new google.maps.Marker({
            position,
            map,
            icon: {
                url: iconUrl,
                scaledSize: new google.maps.Size(32,32)
            },
            title: event.headline || event.event_type || "Open511 Event"
        });

        const infoWindowContent = buildInfoWindowContent(event);
        const infoWindow = new google.maps.InfoWindow({ content: infoWindowContent });
        marker.addListener("click", () => infoWindow.open({ anchor: marker, map }));
    }

    function buildInfoWindowContent(event){
        const headline    = event.headline     || "(No Headline)";
        const description = event.description  || "(No Description)";
        const severity    = event.severity     || "(No Severity)";
        const status      = event.status       || "(No Status)";
        const createdDate = event.created      || "(No Created Date)";
        const updatedDate = event.updated      || "(No Updated Date)";

        return `
          <div style="min-width:250px">
            <h3>${headline} (${event.event_type})</h3>
            <p><strong>Description:</strong> ${description}</p>
            <p><strong>Severity:</strong> ${severity}</p>
            <p><strong>Status:</strong> ${status}</p>
            <p><strong>Created:</strong> ${createdDate}</p>
            <p><strong>Updated:</strong> ${updatedDate}</p>
          </div>
        `;
    }
</script>

</body>
</html>

