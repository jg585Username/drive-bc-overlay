<!DOCTYPE html>
<html>
<head>
    <title>BC Traffic Map with Elevation & Axis Labels</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1.0" />
    <!-- Replace YOUR_API_KEY with your actual API key that has Elevation API enabled -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCIzypwXHVm4201GULNbcXz3L1fMPEaouE"></script>
</head>
<body>

<h1>BC Traffic Map</h1>
<div id="map" style="width:100%; height:600px;"></div>

<h1>Select an Area</h1>
<select id="areasDropdown">
    <option value="">-- Choose an Area --</option>
</select>

<script>
    let map;
    let elevationService;

    // Predefined area centers for BC
    const areaCenters = {
        "drivebc.ca/1":  { lat: 49.2058, lng: -123.0233 },
        "drivebc.ca/2":  { lat: 48.4611, lng: -123.3787 },
        "drivebc.ca/3":  { lat: 50.5074, lng: -116.0311 },
        "drivebc.ca/4":  { lat: 49.3297, lng: -116.7014 },
        "drivebc.ca/5":  { lat: 51.0002, lng: -118.1955 },
        "drivebc.ca/6":  { lat: 50.6718, lng: -120.3241 },
        "drivebc.ca/7":  { lat: 52.9809, lng: -122.4933 },
        "drivebc.ca/8":  { lat: 55.7579, lng: -120.2373 },
        "drivebc.ca/9":  { lat: 53.9101, lng: -122.7617 },
        "drivebc.ca/10": { lat: 54.7814, lng: -127.1661 },
        "drivebc.ca/11": { lat: 54.0552, lng: -128.6526 }
    };

    function initMap() {
        map = new google.maps.Map(document.getElementById("map"), {
            center: { lat: 49.2827, lng: -123.1207 },
            zoom: 6
        });

        // Elevation service
        elevationService = new google.maps.ElevationService();

        // Load roads
        loadRoadPolylines("map.geojson");
        loadRoadPolylines("westbay_cypress.geojson");

        // Load events
        loadEventsWithIcons();
    }

    window.onload = initMap;

    // Fetch areas from Open511
    fetch("https://api.open511.gov.bc.ca/areas?format=json")
        .then(r => r.json())
        .then(data => {
            const areas = data.areas;
            const dropdown = document.getElementById("areasDropdown");
            areas.forEach(a => {
                const opt = document.createElement("option");
                opt.value = a.id;
                opt.textContent = a.name;
                dropdown.appendChild(opt);
            });
        })
        .catch(err => console.error("Error fetching areas:", err));

    document.getElementById("areasDropdown").addEventListener("change", e => {
        const selectedId = e.target.value;
        const coords = areaCenters[selectedId];
        if (coords) {
            map.setCenter(coords);
            map.setZoom(12);
        }
    });

    // Load road data from local GeoJSON
    function loadRoadPolylines(file) {
        fetch(file)
            .then(r => r.json())
            .then(geo => {
                const roadFeatures = geo.features.filter(f => f.properties && f.properties.highway);
                roadFeatures.forEach(feature => {
                    const geom = feature.geometry;
                    const name = feature.properties.name || "(Unnamed Road)";
                    const lengthKm = calculateLineLength(geom);

                    if (geom.type === "LineString") {
                        drawPolyline(geom.coordinates, name, lengthKm);
                    } else if (geom.type === "MultiLineString") {
                        geom.coordinates.forEach(line => {
                            drawPolyline(line, name, lengthKm);
                        });
                    }
                });
            })
            .catch(err => console.error("Error loading", file, err));
    }

    function drawPolyline(coordsArray, roadName, roadLengthKm) {
        const pathLatLng = coordsArray.map(c => ({ lat: c[1], lng: c[0] }));
        const polyline = new google.maps.Polyline({
            path: pathLatLng,
            strokeColor: "#0000FF",
            strokeWeight: 2,
            map
        });

        polyline.roadName = roadName;
        polyline.roadLength = roadLengthKm;
        polyline.pathLatLng = pathLatLng;

        polyline.addListener("click", (e) => {
            // highlight
            polyline.setOptions({ strokeColor: "#FF0000", strokeWeight: 4 });
            // fetch elevation
            getElevationAndShowInfo(polyline, e.latLng);
        });
    }

    // Use ElevationService along path
    function getElevationAndShowInfo(polyline, clickLocation) {
        const pathRequest = {
            path: polyline.pathLatLng,
            samples: 50
        };
        elevationService.getElevationAlongPath(pathRequest, (results, status) => {
            if (status === "OK" && results && results.length > 1) {
                const elevStart = results[0].elevation;
                const elevEnd   = results[results.length - 1].elevation;
                const slopePercent = computeSlopePercent(polyline.pathLatLng, elevStart, elevEnd);

                const elevations = results.map(r => r.elevation);
                showRoadInfoWithElevation(polyline, clickLocation, elevations, slopePercent);
            } else {
                console.warn("ElevationService failed:", status);
                showRoadInfoWithElevation(polyline, clickLocation, null, null);
            }
        });
    }

    // slope = (end_elev - start_elev)/(distance in m) *100%
    function computeSlopePercent(pathLatLng, elevStart, elevEnd) {
        const latLng1 = pathLatLng[0];
        const latLng2 = pathLatLng[pathLatLng.length - 1];
        const distKm = haversineDistance(latLng1.lat, latLng1.lng, latLng2.lat, latLng2.lng);
        const distM = distKm * 1000;
        const elevChange = elevEnd - elevStart;
        return (elevChange / distM) * 100;
    }

    // Show InfoWindow with slope + custom chart
    function showRoadInfoWithElevation(polyline, clickLocation, elevationArray, slopePercent) {
        let uniqueId = "elevChart_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
        let slopeText = slopePercent !== null ? slopePercent.toFixed(2) + "%" : "(No data)";

        // We'll pass the roadName so we can label the chart ends
        let content = `
    <div style="min-width:220px;">
      <p><strong>Road Name:</strong> ${polyline.roadName}</p>
      <p><strong>Length (approx):</strong> ${polyline.roadLength.toFixed(2)} km</p>
      <p><strong>Slope (start-end):</strong> ${slopeText}</p>
  `;

        if (elevationArray) {
            content += `
    <p><strong>Elevation Profile:</strong></p>
    <canvas id="${uniqueId}" width="300" height="150" style="border:1px solid #ccc;"></canvas>
  `;
        }

        content += `</div>`;

        const infoWindow = new google.maps.InfoWindow({
            content,
            position: clickLocation
        });
        infoWindow.open({ map });

        if (elevationArray) {
            google.maps.event.addListenerOnce(infoWindow, "domready", () => {
                drawElevationChart(uniqueId, elevationArray, polyline.roadName);
            });
        }
    }

    // A simple chart with axis + "Start of X" / "End of X"
    function drawElevationChart(canvasId, elevations, roadName) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        const ctx = canvas.getContext("2d");
        const width  = canvas.width;
        const height = canvas.height;

        // Margins for axis
        const marginLeft   = 40;
        const marginRight  = 20;
        const marginTop    = 20;
        const marginBottom = 40;

        // Chart drawing region
        const chartWidth  = width  - marginLeft - marginRight;
        const chartHeight = height - marginTop  - marginBottom;

        // Data stats
        const minElev = Math.min(...elevations);
        const maxElev = Math.max(...elevations);
        const range   = (maxElev - minElev) || 1;

        // Clear the canvas
        ctx.clearRect(0, 0, width, height);

        // 1) Draw axes
        ctx.beginPath();
        // Y-axis
        ctx.moveTo(marginLeft, marginTop);
        ctx.lineTo(marginLeft, marginTop + chartHeight);
        // X-axis
        ctx.lineTo(marginLeft + chartWidth, marginTop + chartHeight);
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1.5;
        ctx.stroke();

// Replace lines in drawElevationChart() that do the x-axis labeling:
        ctx.font = "12px Arial";

// Draw 'Start of' on the left
        ctx.textAlign = "left";
        ctx.fillText("Start of", marginLeft, marginTop + chartHeight + 15);

// Draw the road name below 'Start of' on the left
        ctx.fillText(roadName, marginLeft, marginTop + chartHeight + 30);

// Draw 'End of' on the right
        ctx.textAlign = "right";
        ctx.fillText("End of", marginLeft + chartWidth, marginTop + chartHeight + 15);

// Road name below 'End of' on the right
        ctx.fillText(roadName, marginLeft + chartWidth, marginTop + chartHeight + 30);


        // 3) Y-axis ticks/labels (for simplicity, 3 or 4 ticks: min, mid, max)
        //    You can do more increments if you'd like
        const numTicks = 3;
        for (let i = 0; i <= numTicks; i++) {
            const value = minElev + (range * i / numTicks);
            const y = marginTop + chartHeight - ((value - minElev)/range)*chartHeight;

            ctx.beginPath();
            ctx.moveTo(marginLeft - 5, y);
            ctx.lineTo(marginLeft, y);
            ctx.stroke();

            ctx.textAlign = "right";
            ctx.fillText(value.toFixed(0)+"m", marginLeft - 8, y+3); // label
        }

        // 4) Plot the line
        ctx.beginPath();
        elevations.forEach((elev, i) => {
            // scale to chart area
            const xRatio = i/(elevations.length-1);
            const x = marginLeft + (xRatio * chartWidth);

            const elevNorm = (elev - minElev)/range;
            const y = marginTop + chartHeight - (elevNorm * chartHeight);

            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.strokeStyle = "#FF0000";
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    // Compute approximate length of the geometry in km
    function calculateLineLength(geometry) {
        let totalKm = 0;
        if (geometry.type === "LineString") {
            totalKm = computeCoordsDistance(geometry.coordinates);
        } else if (geometry.type === "MultiLineString") {
            geometry.coordinates.forEach(lineCoords => {
                totalKm += computeCoordsDistance(lineCoords);
            });
        }
        return totalKm;
    }

    // Sum distances for consecutive coords
    function computeCoordsDistance(coords) {
        let dist = 0;
        for (let i=0; i<coords.length-1; i++) {
            const [lon1, lat1] = coords[i];
            const [lon2, lat2] = coords[i+1];
            dist += haversineDistance(lat1, lon1, lat2, lon2);
        }
        return dist;
    }

    // Haversine for lat/lon in degrees, returns km
    function haversineDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Earth radius in km
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat/2)**2
            + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R*c;
    }

    function toRad(val){ return (val * Math.PI)/180; }

    // Load events from Open511, place markers for 3 event types
    function loadEventsWithIcons() {
        fetch("https://api.open511.gov.bc.ca/events?format=json&status=ACTIVE")
            .then(r => r.json())
            .then(data => {
                if (data.events) {
                    data.events.forEach(e => {
                        if(["CONSTRUCTION","SPECIAL_EVENT","INCIDENT"].includes(e.event_type)){
                            placeEventMarker(e);
                        }
                    });
                }
            })
            .catch(err => console.error("Error fetching events:", err));
    }

    function placeEventMarker(event) {
        if (!event.geography || event.geography.type !== "Point") return;
        const coords = event.geography.coordinates;
        if (!Array.isArray(coords) || coords.length<2) return;

        const position = { lat: coords[1], lng: coords[0] };

        let iconUrl;
        switch(event.event_type){
            case "CONSTRUCTION":  iconUrl="images/construction.png"; break;
            case "SPECIAL_EVENT": iconUrl="images/special_event.png"; break;
            case "INCIDENT":      iconUrl="images/incident.png"; break;
            default: return;
        }

        const marker = new google.maps.Marker({
            position,
            map,
            icon: {
                url: iconUrl,
                scaledSize: new google.maps.Size(32,32)
            },
            title: event.headline || event.event_type || "Open511 Event"
        });

        const infoWindowContent = buildInfoWindowContent(event);
        const infoWindow = new google.maps.InfoWindow({ content: infoWindowContent });
        marker.addListener("click", () => infoWindow.open({ anchor: marker, map }));
    }

    function buildInfoWindowContent(event){
        const headline    = event.headline     || "(No Headline)";
        const description = event.description  || "(No Description)";
        const severity    = event.severity     || "(No Severity)";
        const status      = event.status       || "(No Status)";
        const createdDate = event.created      || "(No Created Date)";
        const updatedDate = event.updated      || "(No Updated Date)";

        return `
    <div style="min-width:250px">
      <h3>${headline} (${event.event_type})</h3>
      <p><strong>Description:</strong> ${description}</p>
      <p><strong>Severity:</strong> ${severity}</p>
      <p><strong>Status:</strong> ${status}</p>
      <p><strong>Created:</strong> ${createdDate}</p>
      <p><strong>Updated:</strong> ${updatedDate}</p>
    </div>
  `;
    }
</script>

</body>
</html>
