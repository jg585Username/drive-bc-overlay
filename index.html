<!DOCTYPE html>
<html>
<head>
    <title>BC Traffic Map â€“ Zoom-Level Loading & OSM Tags</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1.0" />

    <!-- Instead of embedding your key in code, we load it from config.js -->
    <script src="config.js"></script>
    <script>
        function loadGoogleMaps() {
            const script = document.createElement("script");
            script.src = `https://maps.googleapis.com/maps/api/js?key=${CONFIG.GOOGLE_MAPS_API_KEY}`;
            script.async = true;
            script.defer = true;
            script.onload = () => initMap(); // Initialize map after loading
            document.head.appendChild(script);
        }
        loadGoogleMaps();
    </script>

    <style>
        /* Full screen map + zero margin */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
        }
        #map {
            width: 100%;
            height: 100vh; /* fill the viewport height */
        }
        /* Position the dropdown on top of the map */
        #areasDropdown {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 9999;
            font-size: 14px;
            padding: 5px;
        }
    </style>
</head>
<body>

<div id="map"></div>
<select id="areasDropdown">
    <option value="">-- Choose an Area --</option>
</select>

<script>
    // Keep references for polylines & infoWindows so we can manage them
    let map;
    let elevationService;

    // For displaying only one polyline selection at a time:
    let currentlySelectedPolyline = null;
    let currentlySelectedInfoWindow = null;

    // Store *all* loaded roads in memory, and only render what's needed
    let allRoadFeatures = [];
    let drawnPolylines = []; // references to displayed polylines

    // Zoom threshold: below this, only major roads are displayed
    const ZOOM_THRESHOLD = 12;
    // Let's define which highway types are "major" roads:
    const MAJOR_ROAD_TYPES = [
        "motorway", "trunk", "primary", "secondary",
        "motorway_link", "trunk_link", "primary_link", "secondary_link"
    ];

    // Predefined area centers
    const areaCenters = {
        "drivebc.ca/1":  { lat: 49.2058, lng: -123.0233 },
        "drivebc.ca/2":  { lat: 48.4611, lng: -123.3787 },
        "drivebc.ca/3":  { lat: 50.5074, lng: -116.0311 },
        "drivebc.ca/4":  { lat: 49.3297, lng: -116.7014 },
        "drivebc.ca/5":  { lat: 51.0002, lng: -118.1955 },
        "drivebc.ca/6":  { lat: 50.6718, lng: -120.3241 },
        "drivebc.ca/7":  { lat: 52.9809, lng: -122.4933 },
        "drivebc.ca/8":  { lat: 55.7579, lng: -120.2373 },
        "drivebc.ca/9":  { lat: 53.9101, lng: -122.7617 },
        "drivebc.ca/10": { lat: 54.7814, lng: -127.1661 },
        "drivebc.ca/11": { lat: 54.0552, lng: -128.6526 }
    };

    function initMap() {
        map = new google.maps.Map(document.getElementById("map"), {
            center: { lat: 49.2827, lng: -123.1207 },
            zoom: 6
        });
        elevationService = new google.maps.ElevationService();

        // Listen for zoom changes to re-render polylines
        map.addListener("zoom_changed", () => {
            renderPolylinesForZoom();
        });

        // Load multiple GeoJSON files
        loadRoadPolylines("map.geojson");
        loadRoadPolylines("westbay_cypress.geojson");
        loadRoadPolylines("burnaby_bsss.geojson");
        loadRoadPolylines("burnaby_highway.geojson");

        // Then load events
        loadEventsWithIcons();

        // Fetch areas from Open511
        fetch("https://api.open511.gov.bc.ca/areas?format=json")
            .then(r => r.json())
            .then(data => {
                const areas = data.areas || [];
                const dropdown = document.getElementById("areasDropdown");
                areas.forEach(a => {
                    const opt = document.createElement("option");
                    opt.value = a.id;
                    opt.textContent = a.name;
                    dropdown.appendChild(opt);
                });
            })
            .catch(err => console.error("Error fetching areas:", err));

        // On area dropdown change
        document.getElementById("areasDropdown").addEventListener("change", e => {
            const selectedId = e.target.value;
            const coords = areaCenters[selectedId];
            if (coords) {
                map.setCenter(coords);
                map.setZoom(12);
            }
        });
    }

    /**
     * 1) We load each GeoJSON in memory (allRoadFeatures),
     *    but do NOT immediately draw everything.
     * 2) Once loaded, we call renderPolylinesForZoom() to show/hide roads.
     */
    function loadRoadPolylines(file) {
        fetch(file)
            .then(r => r.json())
            .then(geo => {
                // Filter for features that have a 'highway' tag
                const roadFeatures = geo.features.filter(f => f.properties && f.properties.highway);

                roadFeatures.forEach(feature => {
                    const props = feature.properties || {};
                    const geom  = feature.geometry;

                    const roadName     = props.name || "(Unnamed Road)";
                    const roadLengthKm = calculateLineLength(geom);

                    // Basic fields (default to "(N/A)")
                    let cycleway      = props.cycleway      || "(N/A)";
                    let sidewalk      = props.sidewalk      || "(N/A)";
                    let surface       = props.surface       || "(N/A)";
                    let maxspeed      = props.maxspeed      || "(N/A)";
                    let lanes         = props.lanes         || "(N/A)";
                    let width         = props.width         || "(N/A)";
                    let oneway        = props.oneway        || "(N/A)";
                    let access        = props.access        || "(N/A)";
                    let motorVehicle  = props.motor_vehicle || "(N/A)";
                    let bicycle       = props.bicycle       || "(N/A)";
                    let foot          = props.foot          || "(N/A)";
                    let lit           = props.lit           || "(N/A)";
                    let busway        = props.busway        || "(N/A)";
                    let turn          = props.turn          || "(N/A)";

                    // Override logic if surface is asphalt/paved
                    if ((surface === "asphalt" || surface === "paved")) {
                        if (maxspeed === "(N/A)") {
                            maxspeed = "50";
                        }
                        if (access === "(N/A)") {
                            access = "Public";
                        }
                        if (motorVehicle === "(N/A)") {
                            motorVehicle = "Designated";
                        }
                    }

                    // We'll push each segment (LineString or part of MultiLineString) as a "road object"
                    if (geom.type === "LineString") {
                        allRoadFeatures.push({ props, roadName, roadLengthKm,
                            cycleway, sidewalk, surface, maxspeed,
                            lanes, width, oneway, access,
                            motorVehicle, bicycle, foot, lit,
                            busway, turn,
                            coordinates: geom.coordinates });
                    } else if (geom.type === "MultiLineString") {
                        geom.coordinates.forEach(lineCoords => {
                            allRoadFeatures.push({ props, roadName, roadLengthKm,
                                cycleway, sidewalk, surface, maxspeed,
                                lanes, width, oneway, access,
                                motorVehicle, bicycle, foot, lit,
                                busway, turn,
                                coordinates: lineCoords });
                        });
                    }
                });

                // Now that we've loaded more features, re-render according to the current zoom
                renderPolylinesForZoom();
            })
            .catch(err => console.error("Error loading", file, err));
    }

    /**
     * Based on the current zoom, decide which roads to show:
     *  - If zoom < ZOOM_THRESHOLD => show only "major" roads
     *  - Else => show all roads
     */
    function renderPolylinesForZoom() {
        // 1) Clear currently drawn polylines
        clearDrawnPolylines();

        const currentZoom = map.getZoom();

        allRoadFeatures.forEach(road => {
            const hwyType = road.props.highway; // e.g. "residential" or "motorway"
            const isMajor = MAJOR_ROAD_TYPES.includes(hwyType);

            // If currentZoom < threshold, only show major roads
            // If currentZoom >= threshold, show everything
            if ((currentZoom < ZOOM_THRESHOLD && isMajor) ||
                (currentZoom >= ZOOM_THRESHOLD)) {
                // create polylines
                drawPolyline(road);
            }
        });
    }

    // Clears the polylines currently on the map
    function clearDrawnPolylines() {
        drawnPolylines.forEach(obj => {
            obj.polylineVisible.setMap(null);
            obj.polylineHitbox.setMap(null);
        });
        drawnPolylines = [];
    }

    // Actually draws the polylines for a single "road object"
    // (the code that used to be in drawPolyline coords + roadInfo)
    function drawPolyline(road) {
        const pathLatLng = road.coordinates.map(c => ({ lat: c[1], lng: c[0] }));

        // Visible line with a thin stroke
        const polylineVisible = new google.maps.Polyline({
            path: pathLatLng,
            strokeColor: "#0000FF",
            strokeWeight: 2,
            map
        });

        // Hit-detection overlay
        const polylineHitbox = new google.maps.Polyline({
            path: pathLatLng,
            strokeColor: "#0000FF",
            strokeOpacity: 0.0,
            strokeWeight: 12,
            map
        });

        // Attach data to the visible line
        polylineVisible.roadName       = road.roadName;
        polylineVisible.roadLength     = road.roadLengthKm;
        polylineVisible.pathLatLng     = pathLatLng;
        polylineVisible.cycleway       = road.cycleway;
        polylineVisible.sidewalk       = road.sidewalk;
        polylineVisible.surface        = road.surface;
        polylineVisible.maxspeed       = road.maxspeed;
        polylineVisible.lanes          = road.lanes;
        polylineVisible.width          = road.width;
        polylineVisible.oneway         = road.oneway;
        polylineVisible.access         = road.access;
        polylineVisible.motorVehicle   = road.motorVehicle;
        polylineVisible.bicycle        = road.bicycle;
        polylineVisible.foot           = road.foot;
        polylineVisible.lit            = road.lit;
        polylineVisible.busway         = road.busway;
        polylineVisible.turn           = road.turn;

        // Clicking the hitbox
        polylineHitbox.addListener("click", (e) => {
            // If there's a previously selected polyline, revert it
            if (currentlySelectedPolyline) {
                currentlySelectedPolyline.setOptions({
                    strokeColor: "#0000FF",
                    strokeWeight: 2
                });
            }
            // Close the old InfoWindow if any
            if (currentlySelectedInfoWindow) {
                currentlySelectedInfoWindow.close();
            }

            // Highlight this newly clicked line
            polylineVisible.setOptions({
                strokeColor: "#FF0000",
                strokeWeight: 4
            });

            // Show slope & OSM tags
            getElevationAndShowInfo(polylineVisible, e.latLng);

            currentlySelectedPolyline = polylineVisible;
            // The new infoWindow is set inside getElevationAndShowInfo
        });

        // Remember these polylines so we can remove them later if needed
        drawnPolylines.push({ polylineVisible, polylineHitbox });
    }

    // For slope data
    function getElevationAndShowInfo(polyline, clickLocation) {
        const pathRequest = {
            path: polyline.pathLatLng,
            samples: 50
        };
        elevationService.getElevationAlongPath(pathRequest, (results, status) => {
            if (status === "OK" && results && results.length > 1) {
                const elevStart = results[0].elevation;
                const elevEnd   = results[results.length - 1].elevation;
                const slopePercent = computeSlopePercent(polyline.pathLatLng, elevStart, elevEnd);

                const elevations = results.map(r => r.elevation);
                const infoWindow = showRoadInfoWithElevation(polyline, clickLocation, elevations, slopePercent);
                currentlySelectedInfoWindow = infoWindow;
            } else {
                const infoWindow = showRoadInfoWithElevation(polyline, clickLocation, null, null);
                currentlySelectedInfoWindow = infoWindow;
            }
        });
    }

    function computeSlopePercent(pathLatLng, elevStart, elevEnd) {
        const latLng1 = pathLatLng[0];
        const latLng2 = pathLatLng[pathLatLng.length - 1];
        const distKm  = haversineDistance(latLng1.lat, latLng1.lng, latLng2.lat, latLng2.lng);
        const distM   = distKm * 1000;
        const elevChange = elevEnd - elevStart;
        return (elevChange / distM) * 100;
    }

    // Show InfoWindow with slope + OSM tags, skipping (N/A)
    function showRoadInfoWithElevation(polyline, clickLocation, elevationArray, slopePercent) {
        let uniqueId = "elevChart_" + Date.now() + "_" + Math.floor(Math.random() * 1000);
        let slopeText = (slopePercent !== null) ? slopePercent.toFixed(2) + "%" : "(No data)";

        const name     = polyline.roadName;
        const lengthKm = polyline.roadLength.toFixed(2);

        // We'll build HTML, skipping any tag that is "(N/A)"
        function makeTagLine(label, value) {
            if (value === "(N/A)") return ""; // skip if N/A
            return `<p><strong>${label}:</strong> ${value}</p>`;
        }

        let content = `
      <div style="min-width:220px;">
        <p><strong>Road Name:</strong> ${name}</p>
        <p><strong>Length (approx):</strong> ${lengthKm} km</p>
        <p><strong>Slope (start-end):</strong> ${slopeText}</p>
        <hr/>
        ${makeTagLine("Cycleway", polyline.cycleway)}
        ${makeTagLine("Sidewalk", polyline.sidewalk)}
        ${makeTagLine("Surface", polyline.surface)}
        ${makeTagLine("Max Speed (km/h)", polyline.maxspeed)}
        ${makeTagLine("Lanes", polyline.lanes)}
        ${makeTagLine("Width", polyline.width)}
        ${makeTagLine("Oneway", polyline.oneway)}
        ${makeTagLine("Access", polyline.access)}
        ${makeTagLine("Motor Vehicle", polyline.motorVehicle)}
        ${makeTagLine("Bicycle", polyline.bicycle)}
        ${makeTagLine("Foot", polyline.foot)}
        ${makeTagLine("Lit (Lighting)", polyline.lit)}
        ${makeTagLine("Busway", polyline.busway)}
        ${makeTagLine("Turn", polyline.turn)}
    `;

        // If we have elevation data
        if (elevationArray) {
            content += `
        <p><strong>Elevation Profile:</strong></p>
        <canvas id="${uniqueId}" width="300" height="150" style="border:1px solid #ccc;"></canvas>
      `;
        }
        content += `</div>`;

        const infoWindow = new google.maps.InfoWindow({
            content,
            position: clickLocation
        });
        infoWindow.open({ map });

        // Draw chart if we have elevation data
        if (elevationArray) {
            google.maps.event.addListenerOnce(infoWindow, "domready", () => {
                drawElevationChart(uniqueId, elevationArray, name);
            });
        }
        return infoWindow;
    }

    // Basic line chart with axis
    function drawElevationChart(canvasId, elevations, roadName) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        const ctx = canvas.getContext("2d");
        const width  = canvas.width;
        const height = canvas.height;

        // Margins
        const marginLeft   = 40;
        const marginRight  = 20;
        const marginTop    = 20;
        const marginBottom = 40;

        const chartWidth  = width  - marginLeft - marginRight;
        const chartHeight = height - marginTop  - marginBottom;

        const minElev = Math.min(...elevations);
        const maxElev = Math.max(...elevations);
        const range   = (maxElev - minElev) || 1;

        ctx.clearRect(0, 0, width, height);

        // Axes
        ctx.beginPath();
        ctx.moveTo(marginLeft, marginTop);
        ctx.lineTo(marginLeft, marginTop + chartHeight);
        ctx.lineTo(marginLeft + chartWidth, marginTop + chartHeight);
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // X-axis labeling
        ctx.font = "12px Arial";
        ctx.textAlign = "left";
        ctx.fillText("Start of", marginLeft, marginTop + chartHeight + 15);
        ctx.fillText(roadName, marginLeft, marginTop + chartHeight + 30);

        ctx.textAlign = "right";
        ctx.fillText("End of", marginLeft + chartWidth, marginTop + chartHeight + 15);
        ctx.fillText(roadName, marginLeft + chartWidth, marginTop + chartHeight + 30);

        // Y-axis ticks (min, mid, max)
        const numTicks = 3;
        for (let i = 0; i <= numTicks; i++) {
            const value = minElev + (range * i / numTicks);
            const y = marginTop + chartHeight - ((value - minElev)/range)*chartHeight;

            ctx.beginPath();
            ctx.moveTo(marginLeft - 5, y);
            ctx.lineTo(marginLeft, y);
            ctx.stroke();

            ctx.textAlign = "right";
            ctx.fillText(value.toFixed(0) + "m", marginLeft - 8, y + 3);
        }

        // Plot the line
        ctx.beginPath();
        elevations.forEach((elev, i) => {
            const xRatio = i / (elevations.length - 1);
            const x = marginLeft + (xRatio * chartWidth);
            const elevNorm = (elev - minElev) / range;
            const y = marginTop + chartHeight - (elevNorm * chartHeight);

            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.strokeStyle = "#FF0000";
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    // Approx length
    function calculateLineLength(geometry) {
        let totalKm = 0;
        if (geometry.type === "LineString") {
            totalKm = computeCoordsDistance(geometry.coordinates);
        } else if (geometry.type === "MultiLineString") {
            geometry.coordinates.forEach(lineCoords => {
                totalKm += computeCoordsDistance(lineCoords);
            });
        }
        return totalKm;
    }

    // Summation of consecutive segments
    function computeCoordsDistance(coords) {
        let dist = 0;
        for (let i = 0; i < coords.length - 1; i++) {
            const [lon1, lat1] = coords[i];
            const [lon2, lat2] = coords[i + 1];
            dist += haversineDistance(lat1, lon1, lat2, lon2);
        }
        return dist;
    }

    // Basic Haversine formula
    function haversineDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Earth radius in km
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat/2)**2
            + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R*c;
    }

    function toRad(val){ return (val * Math.PI) / 180; }

    // Load events from Open511
    function loadEventsWithIcons() {
        fetch("https://api.open511.gov.bc.ca/events?format=json&status=ACTIVE")
            .then(r => r.json())
            .then(data => {
                if (data.events) {
                    data.events.forEach(e => {
                        if(["CONSTRUCTION","SPECIAL_EVENT","INCIDENT"].includes(e.event_type)){
                            placeEventMarker(e);
                        }
                    });
                }
            })
            .catch(err => console.error("Error fetching events:", err));
    }

    function placeEventMarker(event) {
        if (!event.geography || event.geography.type !== "Point") return;
        const coords = event.geography.coordinates;
        if (!Array.isArray(coords) || coords.length < 2) return;

        const position = { lat: coords[1], lng: coords[0] };

        let iconUrl;
        switch(event.event_type){
            case "CONSTRUCTION":  iconUrl="images/construction.png"; break;
            case "SPECIAL_EVENT": iconUrl="images/special_event.png"; break;
            case "INCIDENT":      iconUrl="images/incident.png"; break;
            default: return;
        }

        const marker = new google.maps.Marker({
            position,
            map,
            icon: {
                url: iconUrl,
                scaledSize: new google.maps.Size(32,32)
            },
            title: event.headline || event.event_type || "Open511 Event"
        });

        const infoWindowContent = buildInfoWindowContent(event);
        const infoWindow = new google.maps.InfoWindow({ content: infoWindowContent });
        marker.addListener("click", () => {
            infoWindow.open({ anchor: marker, map });
        });
    }

    function buildInfoWindowContent(event){
        const headline    = event.headline     || "(No Headline)";
        const description = event.description  || "(No Description)";
        const severity    = event.severity     || "(No Severity)";
        const status      = event.status       || "(No Status)";
        const createdDate = event.created      || "(No Created Date)";
        const updatedDate = event.updated      || "(No Updated Date)";

        return `
      <div style="min-width:250px">
        <h3>${headline} (${event.event_type})</h3>
        <p><strong>Description:</strong> ${description}</p>
        <p><strong>Severity:</strong> ${severity}</p>
        <p><strong>Status:</strong> ${status}</p>
        <p><strong>Created:</strong> ${createdDate}</p>
        <p><strong>Updated:</strong> ${updatedDate}</p>
      </div>
    `;
    }
</script>
</body>
</html>
