<!DOCTYPE html>
<html>
<head>
    <title>BC Traffic Map with Elevation</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1.0" />
    <!-- Replace YOUR_API_KEY with your actual API key -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCIzypwXHVm4201GULNbcXz3L1fMPEaouE"></script>
</head>
<body>

<h1>BC Traffic Map</h1>
<div id="map" style="width:100%;height:600px;"></div>

<h1>Select an Area</h1>
<select id="areasDropdown">
    <option value="">-- Choose an Area --</option>
</select>

<script>
    let map;
    // We'll need this for elevation calls
    let elevationService;

    const areaCenters = {
        "drivebc.ca/1":  { lat: 49.2058, lng: -123.0233 },
        "drivebc.ca/2":  { lat: 48.4611, lng: -123.3787 },
        "drivebc.ca/3":  { lat: 50.5074, lng: -116.0311 },
        "drivebc.ca/4":  { lat: 49.3297, lng: -116.7014 },
        "drivebc.ca/5":  { lat: 51.0002, lng: -118.1955 },
        "drivebc.ca/6":  { lat: 50.6718, lng: -120.3241 },
        "drivebc.ca/7":  { lat: 52.9809, lng: -122.4933 },
        "drivebc.ca/8":  { lat: 55.7579, lng: -120.2373 },
        "drivebc.ca/9":  { lat: 53.9101, lng: -122.7617 },
        "drivebc.ca/10": { lat: 54.7814, lng: -127.1661 },
        "drivebc.ca/11": { lat: 54.0552, lng: -128.6526 }
    };

    function initMap() {
        map = new google.maps.Map(document.getElementById("map"), {
            center: { lat: 49.2827, lng: -123.1207 },
            zoom: 6
        });

        // Elevation Service
        elevationService = new google.maps.ElevationService();

        // Load roads
        loadRoadPolylines("map.geojson");
        loadRoadPolylines("westbay_cypress.geojson");

        // Load events
        loadEventsWithIcons();
    }

    window.onload = initMap;

    // Fetch areas from Open511
    fetch("https://api.open511.gov.bc.ca/areas?format=json")
        .then(r => r.json())
        .then(data => {
            const areas = data.areas;
            const dropdown = document.getElementById("areasDropdown");
            areas.forEach(areaItem => {
                const option = document.createElement("option");
                option.value = areaItem.id;
                option.textContent = areaItem.name;
                dropdown.appendChild(option);
            });
        })
        .catch(err => console.error("Error fetching areas:", err));

    document.getElementById("areasDropdown").addEventListener("change", e => {
        const selectedAreaId = e.target.value;
        const coords = areaCenters[selectedAreaId];
        if (coords) {
            map.setCenter(coords);
            map.setZoom(12);
        }
    });

    function loadRoadPolylines(file) {
        fetch(file)
            .then(r => r.json())
            .then(geo => {
                const roadFeatures = geo.features.filter(f => f.properties && f.properties.highway);
                roadFeatures.forEach(feature => {
                    const geom = feature.geometry;
                    const name = feature.properties.name || "(Unnamed Road)";
                    const lengthKm = calculateLineLength(geom);

                    if (geom.type === "LineString") {
                        drawPolyline(geom.coordinates, name, lengthKm);
                    } else if (geom.type === "MultiLineString") {
                        geom.coordinates.forEach(line => {
                            drawPolyline(line, name, lengthKm);
                        });
                    }
                });
            })
            .catch(err => console.error("Error loading", file, err));
    }

    // Create a polyline and add click listener
    function drawPolyline(coordsArray, roadName, roadLengthKm) {
        const pathLatLng = coordsArray.map(c => ({ lat: c[1], lng: c[0] }));
        const polyline = new google.maps.Polyline({
            path: pathLatLng,
            strokeColor: "#0000FF",
            strokeWeight: 2,
            map
        });

        // store metadata
        polyline.roadName = roadName;
        polyline.roadLength = roadLengthKm;
        polyline.pathLatLng = pathLatLng;

        polyline.addListener("click", (e) => {
            // highlight
            polyline.setOptions({ strokeColor: "#FF0000", strokeWeight: 4 });
            // get elevation + slope
            getElevationAndShowInfo(polyline, e.latLng);
        });
    }

    // Use ElevationService to get a set of samples along the path
    function getElevationAndShowInfo(polyline, clickLocation) {
        // We'll sample the path at, say, 50 points
        const pathRequest = {
            path: polyline.pathLatLng,
            samples: 50
        };

        elevationService.getElevationAlongPath(pathRequest, (results, status) => {
            if (status === "OK" && results && results.length > 1) {
                // compute slope from first to last
                const elevStart = results[0].elevation;
                const elevEnd   = results[results.length - 1].elevation;
                const slopePercent = computeSlopePercent(polyline.pathLatLng, elevStart, elevEnd);
                // Build a small chart data array
                const elevations = results.map(r => r.elevation);

                // Show InfoWindow
                showRoadInfoWithElevation(polyline, clickLocation, elevations, slopePercent);
            } else {
                console.warn("ElevationService failed:", status);
                showRoadInfoWithElevation(polyline, clickLocation, null, null);
            }
        });
    }

    // Slope = (end_elev - start_elev) / horizontal_distance * 100%
    function computeSlopePercent(pathLatLng, elevStart, elevEnd) {
        // horizontal distance in km between first and last point
        const latLng1 = pathLatLng[0];
        const latLng2 = pathLatLng[pathLatLng.length - 1];
        const distKm = haversineDistance(latLng1.lat, latLng1.lng, latLng2.lat, latLng2.lng);
        const distM  = distKm * 1000;  // in meters

        const elevChange = elevEnd - elevStart; // in meters if Elevation API returns meters
        // slope in percent
        return (elevChange / distM) * 100;
    }

    // Build an InfoWindow with a mini chart + slope
    function showRoadInfoWithElevation(polyline, clickLocation, elevationArray, slopePercent) {
        // Build HTML
        let slopeText = slopePercent !== null
            ? slopePercent.toFixed(2) + "%"
            : "(No Elevation Data)";

        let content = `
          <div style="min-width:200px;">
            <p><strong>Road Name:</strong> ${polyline.roadName}</p>
            <p><strong>Length (approx):</strong> ${polyline.roadLength.toFixed(2)} km</p>
            <p><strong>Slope (start-end):</strong> ${slopeText}</p>
        `;

        // If we have elevation data, add a simple canvas chart
        if (elevationArray) {
            content += `
            <p><strong>Elevation Profile:</strong></p>
            <canvas id="elevChart" width="200" height="100" style="border:1px solid #ccc;"></canvas>
          `;
        }
        content += `</div>`;

        const infoWindow = new google.maps.InfoWindow({
            content,
            position: clickLocation
        });
        infoWindow.open({ map });

        // Once the InfoWindow is rendered, we can draw the chart if we have data
        if (elevationArray) {
            google.maps.event.addListenerOnce(infoWindow, "domready", () => {
                drawElevationChart("elevChart", elevationArray);
            });
        }
    }

    // A simple "sparkline" approach using the <canvas>
    function drawElevationChart(canvasId, elevations) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        const ctx = canvas.getContext("2d");
        // find min & max to scale
        const min = Math.min(...elevations);
        const max = Math.max(...elevations);
        const range = max - min || 1;

        // draw polyline on the canvas
        const width  = canvas.width;
        const height = canvas.height;
        ctx.clearRect(0, 0, width, height);

        ctx.beginPath();
        elevations.forEach((elev, i) => {
            // x from 0..width
            const x = (i / (elevations.length - 1)) * width;
            // y: 0 at top, so we invert
            const normalized = (elev - min) / range; // 0..1
            const y = height - (normalized * height);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.strokeStyle = "#FF0000";
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    // events with icons (unchanged from your code)
    function loadEventsWithIcons() {
        fetch("https://api.open511.gov.bc.ca/events?format=json&status=ACTIVE")
            .then(res => res.json())
            .then(data => {
                if (data.events) {
                    data.events.forEach(event => {
                        if (["CONSTRUCTION","SPECIAL_EVENT","INCIDENT"].includes(event.event_type)) {
                            placeEventMarker(event);
                        }
                    });
                }
            })
            .catch(err => console.error("Error fetching events:", err));
    }

    function placeEventMarker(event) {
        if (!event.geography || event.geography.type !== "Point") return;
        const coords = event.geography.coordinates; // [lon, lat]
        if (!Array.isArray(coords) || coords.length < 2) return;
        const position = { lat: coords[1], lng: coords[0] };

        let iconUrl;
        switch (event.event_type) {
            case "CONSTRUCTION":   iconUrl = "images/construction.png"; break;
            case "SPECIAL_EVENT":  iconUrl = "images/special_event.png"; break;
            case "INCIDENT":       iconUrl = "images/incident.png"; break;
            default: return;
        }

        const marker = new google.maps.Marker({
            position,
            map,
            icon: { url: iconUrl, scaledSize: new google.maps.Size(32, 32) },
            title: event.headline || event.event_type || "Open511 Event"
        });

        const infoWindowContent = buildInfoWindowContent(event);
        const infoWindow = new google.maps.InfoWindow({ content: infoWindowContent });
        marker.addListener("click", () => { infoWindow.open({ anchor: marker, map }); });
    }

    // unchanged from your code
    function buildInfoWindowContent(event) {
        const headline     = event.headline     || "(No Headline)";
        const description  = event.description  || "(No Description)";
        const severity     = event.severity     || "(No Severity)";
        const status       = event.status       || "(No Status)";
        const createdDate  = event.created      || "(No Created Date)";
        const updatedDate  = event.updated      || "(No Updated Date)";

        return `
          <div style="min-width:250px">
            <h3>${headline} (${event.event_type})</h3>
            <p><strong>Description:</strong> ${description}</p>
            <p><strong>Severity:</strong> ${severity}</p>
            <p><strong>Status:</strong> ${status}</p>
            <p><strong>Created:</strong> ${createdDate}</p>
            <p><strong>Updated:</strong> ${updatedDate}</p>
          </div>
        `;
    }

    // The same haversine functions from earlier
    function calculateLineLength(geometry) {
        let totalKm = 0;
        if (geometry.type === "LineString") {
            totalKm = computeCoordsDistance(geometry.coordinates);
        } else if (geometry.type === "MultiLineString") {
            geometry.coordinates.forEach(lineCoords => {
                totalKm += computeCoordsDistance(lineCoords);
            });
        }
        return totalKm;
    }

    function computeCoordsDistance(coordsArray) {
        let dist = 0;
        for (let i = 0; i < coordsArray.length - 1; i++) {
            const [lon1, lat1] = coordsArray[i];
            const [lon2, lat2] = coordsArray[i + 1];
            dist += haversineDistance(lat1, lon1, lat2, lon2);
        }
        return dist;
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat/2)**2
            + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c; // in km
    }

    function toRad(v) { return (v * Math.PI) / 180; }

</script>
</body>
</html>