<!DOCTYPE html>
<html>
<head>
    <title>BC Traffic Map with Elevation & Additional OSM Tags</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1.0" />
    <script src="config.js"></script>
    <script>
        function loadGoogleMaps() {
            const script = document.createElement("script");
            script.src = `https://maps.googleapis.com/maps/api/js?key=${CONFIG.GOOGLE_MAPS_API_KEY}`;
            script.async = true;
            script.defer = true;
            document.head.appendChild(script);
        }
        loadGoogleMaps();
    </script>
</head>
<body>

<h1>BC Traffic Map</h1>
<div id="map" style="width:100%; height:600px;"></div>

<h1>Select an Area</h1>
<select id="areasDropdown">
    <option value="">-- Choose an Area --</option>
</select>

<script>
    let map;
    let elevationService;

    // Predefined area centers for BC (from Open511)
    const areaCenters = {
        "drivebc.ca/1":  { lat: 49.2058, lng: -123.0233 },
        "drivebc.ca/2":  { lat: 48.4611, lng: -123.3787 },
        "drivebc.ca/3":  { lat: 50.5074, lng: -116.0311 },
        "drivebc.ca/4":  { lat: 49.3297, lng: -116.7014 },
        "drivebc.ca/5":  { lat: 51.0002, lng: -118.1955 },
        "drivebc.ca/6":  { lat: 50.6718, lng: -120.3241 },
        "drivebc.ca/7":  { lat: 52.9809, lng: -122.4933 },
        "drivebc.ca/8":  { lat: 55.7579, lng: -120.2373 },
        "drivebc.ca/9":  { lat: 53.9101, lng: -122.7617 },
        "drivebc.ca/10": { lat: 54.7814, lng: -127.1661 },
        "drivebc.ca/11": { lat: 54.0552, lng: -128.6526 }
    };

    function initMap() {
        map = new google.maps.Map(document.getElementById("map"), {
            center: { lat: 49.2827, lng: -123.1207 },
            zoom: 6
        });

        // Elevation service for slope calculations
        elevationService = new google.maps.ElevationService();

        // Load multiple GeoJSON files
        // Example:
        loadRoadPolylines("map.geojson");
        loadRoadPolylines("westbay_cypress.geojson");
        loadRoadPolylines("burnaby_bsss.geojson");  // The Overpass result with additional tags
        loadRoadPolylines("burnaby_highway.geojson");
        // Load events (Open511)
        loadEventsWithIcons();
    }

    window.onload = initMap;

    // Fetch areas from Open511
    fetch("https://api.open511.gov.bc.ca/areas?format=json")
        .then(r => r.json())
        .then(data => {
            const areas = data.areas;
            const dropdown = document.getElementById("areasDropdown");
            areas.forEach(a => {
                const opt = document.createElement("option");
                opt.value = a.id;
                opt.textContent = a.name;
                dropdown.appendChild(opt);
            });
        })
        .catch(err => console.error("Error fetching areas:", err));

    document.getElementById("areasDropdown").addEventListener("change", e => {
        const selectedId = e.target.value;
        const coords = areaCenters[selectedId];
        if (coords) {
            map.setCenter(coords);
            map.setZoom(12);
        }
    });

    function loadRoadPolylines(file) {
        fetch(file)
            .then(r => r.json())
            .then(geo => {
                const roadFeatures = geo.features.filter(f => f.properties && f.properties.highway);

                roadFeatures.forEach(feature => {
                    const props = feature.properties || {};
                    const geom  = feature.geometry;

                    const roadName     = props.name || "(Unnamed Road)";
                    const roadLengthKm = calculateLineLength(geom);

                    // Extract existing tags (with default "(N/A)")
                    let cycleway      = props.cycleway      || "(N/A)";
                    let sidewalk      = props.sidewalk      || "(N/A)";
                    let surface       = props.surface       || "(N/A)";
                    let maxspeed      = props.maxspeed      || "(N/A)";
                    let lanes         = props.lanes         || "(N/A)";
                    let width         = props.width         || "(N/A)";
                    let oneway        = props.oneway        || "(N/A)";
                    let access        = props.access        || "(N/A)";
                    let motorVehicle  = props.motor_vehicle || "(N/A)";
                    let bicycle       = props.bicycle       || "(N/A)";
                    let foot          = props.foot          || "(N/A)";
                    let lit           = props.lit           || "(N/A)";
                    let busway        = props.busway        || "(N/A)";
                    let turn          = props.turn          || "(N/A)";

                    // 1) Override logic:
                    // If surface is asphalt or paved, and maxspeed, access, motorVehicle are "(N/A)",
                    // we assume default: maxspeed=50, access=Public, motor_vehicle=Designated
                    if ((surface === "asphalt" || surface === "paved")) {
                        if (maxspeed === "(N/A)") {
                            maxspeed = "50 km/h";
                        }
                        if (access === "(N/A)") {
                            access = "Public";
                        }
                        if (motorVehicle === "(N/A)") {
                            motorVehicle = "Designated";
                        }
                    }

                    // 2) Pass these final values to drawPolyline
                    if (geom.type === "LineString") {
                        drawPolyline(geom.coordinates, {
                            name:         roadName,
                            lengthKm:     roadLengthKm,
                            cycleway,     sidewalk,
                            surface,      maxspeed,
                            lanes,        width,
                            oneway,       access,
                            motorVehicle, bicycle,
                            foot,         lit,
                            busway,       turn
                        });
                    } else if (geom.type === "MultiLineString") {
                        geom.coordinates.forEach(line => {
                            drawPolyline(line, {
                                name:         roadName,
                                lengthKm:     roadLengthKm,
                                cycleway,     sidewalk,
                                surface,      maxspeed,
                                lanes,        width,
                                oneway,       access,
                                motorVehicle, bicycle,
                                foot,         lit,
                                busway,       turn
                            });
                        });
                    }
                });
            })
            .catch(err => console.error("Error loading", file, err));
    }


    // Create a Polyline and store relevant road data on it
    function drawPolyline(coordsArray, roadInfo) {
        const pathLatLng = coordsArray.map(c => ({ lat: c[1], lng: c[0] }));

        // 1) The visible line with a thin stroke
        const polylineVisible = new google.maps.Polyline({
            path: pathLatLng,
            strokeColor: "#0000FF",
            strokeWeight: 2,
            map
        });

        // 2) The "hit-detection" overlay with a thicker, invisible stroke
        const polylineHitbox = new google.maps.Polyline({
            path: pathLatLng,
            strokeColor: "#0000FF",
            strokeOpacity: 0.0,   // fully transparent
            strokeWeight: 12,     // wide clickable area
            map
        });

        // Attach your data to the VISIBLE line (so we can highlight & display info).
        // If you prefer, store it on the hitbox or both – but we’ll keep it on the visible line.
        polylineVisible.roadName   = roadInfo.name;
        polylineVisible.roadLength = roadInfo.lengthKm;
        polylineVisible.pathLatLng = pathLatLng;

        // OSM tags
        polylineVisible.cycleway     = roadInfo.cycleway;
        polylineVisible.sidewalk     = roadInfo.sidewalk;
        polylineVisible.surface      = roadInfo.surface;
        polylineVisible.maxspeed     = roadInfo.maxspeed;
        polylineVisible.lanes        = roadInfo.lanes;
        polylineVisible.width        = roadInfo.width;
        polylineVisible.oneway       = roadInfo.oneway;
        polylineVisible.access       = roadInfo.access;
        polylineVisible.motorVehicle = roadInfo.motorVehicle;
        polylineVisible.bicycle      = roadInfo.bicycle;
        polylineVisible.foot         = roadInfo.foot;
        polylineVisible.lit          = roadInfo.lit;
        polylineVisible.busway       = roadInfo.busway;
        polylineVisible.turn         = roadInfo.turn;

        // Attach the click listener to the HITBOX, so clicking anywhere
        // in that invisible wide area will trigger the event.
        polylineHitbox.addListener("click", (e) => {
            // Highlight the visible line (red, thicker)
            polylineVisible.setOptions({ strokeColor: "#FF0000", strokeWeight: 4 });
            // Then show slope & OSM tags
            getElevationAndShowInfo(polylineVisible, e.latLng);
        });
    }


    // Query ElevationService for slope data
    function getElevationAndShowInfo(polyline, clickLocation) {
        const pathRequest = {
            path: polyline.pathLatLng,
            samples: 50
        };
        elevationService.getElevationAlongPath(pathRequest, (results, status) => {
            if (status === "OK" && results && results.length > 1) {
                const elevStart = results[0].elevation;
                const elevEnd   = results[results.length - 1].elevation;
                const slopePercent = computeSlopePercent(polyline.pathLatLng, elevStart, elevEnd);

                const elevations = results.map(r => r.elevation);
                showRoadInfoWithElevation(polyline, clickLocation, elevations, slopePercent);
            } else {
                console.warn("ElevationService failed:", status);
                showRoadInfoWithElevation(polyline, clickLocation, null, null);
            }
        });
    }

    // slope = (end_elev - start_elev)/(distance in m)*100%
    function computeSlopePercent(pathLatLng, elevStart, elevEnd) {
        const latLng1 = pathLatLng[0];
        const latLng2 = pathLatLng[pathLatLng.length - 1];
        const distKm  = haversineDistance(latLng1.lat, latLng1.lng, latLng2.lat, latLng2.lng);
        const distM   = distKm * 1000;
        const elevChange = elevEnd - elevStart;
        return (elevChange / distM) * 100;
    }

    // Build and display an InfoWindow with road info, OSM tags, slope, chart
    function showRoadInfoWithElevation(polyline, clickLocation, elevationArray, slopePercent) {
        // Unique ID so multiple charts don't clash
        let uniqueId = "elevChart_" + Date.now() + "_" + Math.floor(Math.random() * 1000);

        let slopeText = slopePercent !== null
            ? slopePercent.toFixed(2) + "%"
            : "(No data)";

        const name     = polyline.roadName;
        const lengthKm = polyline.roadLength.toFixed(2);

        // Additional OSM tags
        const cycleway     = polyline.cycleway;
        const sidewalk     = polyline.sidewalk;
        const surface      = polyline.surface;
        const maxspeed     = polyline.maxspeed;
        const lanes        = polyline.lanes;
        const width        = polyline.width;
        const oneway       = polyline.oneway;
        const access       = polyline.access;
        const motorVehicle = polyline.motorVehicle;
        const bicycle      = polyline.bicycle;
        const foot         = polyline.foot;
        const lit          = polyline.lit;
        const busway       = polyline.busway;
        const turn         = polyline.turn;

        let content = `
          <div style="min-width:220px;">
            <p><strong>Road Name:</strong> ${name}</p>
            <p><strong>Length (approx):</strong> ${lengthKm} km</p>
            <p><strong>Slope (start-end):</strong> ${slopeText}</p>

            <hr/>
            <p><strong>Cycleway:</strong> ${cycleway}</p>
            <p><strong>Sidewalk:</strong> ${sidewalk}</p>
            <p><strong>Surface:</strong> ${surface}</p>
            <p><strong>Max Speed:</strong> ${maxspeed}</p>
            <p><strong>Lanes:</strong> ${lanes}</p>
            <p><strong>Width:</strong> ${width} m</p>
            <p><strong>Oneway:</strong> ${oneway}</p>
            <p><strong>Access:</strong> ${access}</p>
            <p><strong>Motor Vehicle:</strong> ${motorVehicle}</p>
            <p><strong>Bicycle:</strong> ${bicycle}</p>
            <p><strong>Foot:</strong> ${foot}</p>
            <p><strong>Lit (Lighting):</strong> ${lit}</p>
            <p><strong>Busway:</strong> ${busway}</p>
            <p><strong>Turn:</strong> ${turn}</p>
        `;

        // If we have elevation data, show a chart
        if (elevationArray) {
            content += `
              <p><strong>Elevation Profile:</strong></p>
              <canvas id="${uniqueId}" width="300" height="150" style="border:1px solid #ccc;"></canvas>
            `;
        }

        content += `</div>`;

        const infoWindow = new google.maps.InfoWindow({
            content,
            position: clickLocation
        });
        infoWindow.open({ map });

        // If we have elevation data, draw the chart once the DOM is ready
        if (elevationArray) {
            google.maps.event.addListenerOnce(infoWindow, "domready", () => {
                drawElevationChart(uniqueId, elevationArray, name);
            });
        }
    }

    // Basic line chart with axes, labeling "Start of X" / "End of X"
    function drawElevationChart(canvasId, elevations, roadName) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;

        const ctx = canvas.getContext("2d");
        const width  = canvas.width;
        const height = canvas.height;

        // Margins for axis
        const marginLeft   = 40;
        const marginRight  = 20;
        const marginTop    = 20;
        const marginBottom = 40;

        // Chart drawing region
        const chartWidth  = width  - marginLeft - marginRight;
        const chartHeight = height - marginTop  - marginBottom;

        // Data stats
        const minElev = Math.min(...elevations);
        const maxElev = Math.max(...elevations);
        const range   = (maxElev - minElev) || 1;

        ctx.clearRect(0, 0, width, height);

        // 1) Draw axes
        ctx.beginPath();
        // Y-axis
        ctx.moveTo(marginLeft, marginTop);
        ctx.lineTo(marginLeft, marginTop + chartHeight);
        // X-axis
        ctx.lineTo(marginLeft + chartWidth, marginTop + chartHeight);
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // 2) X-axis labels
        ctx.font = "12px Arial";
        ctx.textAlign = "left";
        ctx.fillText("Start of", marginLeft, marginTop + chartHeight + 15);
        ctx.fillText(roadName, marginLeft, marginTop + chartHeight + 30);

        ctx.textAlign = "right";
        ctx.fillText("End of", marginLeft + chartWidth, marginTop + chartHeight + 15);
        ctx.fillText(roadName, marginLeft + chartWidth, marginTop + chartHeight + 30);

        // 3) Y-axis ticks (min, mid, max)
        const numTicks = 3;
        for (let i = 0; i <= numTicks; i++) {
            const value = minElev + (range * i / numTicks);
            const y = marginTop + chartHeight - ((value - minElev)/range)*chartHeight;

            ctx.beginPath();
            ctx.moveTo(marginLeft - 5, y);
            ctx.lineTo(marginLeft, y);
            ctx.stroke();

            ctx.textAlign = "right";
            ctx.fillText(value.toFixed(0) + "m", marginLeft - 8, y + 3);
        }

        // 4) Plot the line
        ctx.beginPath();
        elevations.forEach((elev, i) => {
            const xRatio = i / (elevations.length - 1);
            const x = marginLeft + (xRatio * chartWidth);

            const elevNorm = (elev - minElev) / range;
            const y = marginTop + chartHeight - (elevNorm * chartHeight);

            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });
        ctx.strokeStyle = "#FF0000";
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    // Calculate approximate length of geometry in km
    function calculateLineLength(geometry) {
        let totalKm = 0;
        if (geometry.type === "LineString") {
            totalKm = computeCoordsDistance(geometry.coordinates);
        } else if (geometry.type === "MultiLineString") {
            geometry.coordinates.forEach(lineCoords => {
                totalKm += computeCoordsDistance(lineCoords);
            });
        }
        return totalKm;
    }

    // Sum distances for consecutive coords
    function computeCoordsDistance(coords) {
        let dist = 0;
        for (let i = 0; i < coords.length - 1; i++) {
            const [lon1, lat1] = coords[i];
            const [lon2, lat2] = coords[i + 1];
            dist += haversineDistance(lat1, lon1, lat2, lon2);
        }
        return dist;
    }

    // Haversine formula for lat/lon in degrees, returns km
    function haversineDistance(lat1, lon1, lat2, lon2) {
        const R = 6371; // Earth radius in km
        const dLat = toRad(lat2 - lat1);
        const dLon = toRad(lon2 - lon1);
        const a = Math.sin(dLat/2)**2
            + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R*c;
    }

    function toRad(val){
        return (val * Math.PI) / 180;
    }

    // Load events from Open511, place markers for 3 event types
    function loadEventsWithIcons() {
        fetch("https://api.open511.gov.bc.ca/events?format=json&status=ACTIVE")
            .then(r => r.json())
            .then(data => {
                if (data.events) {
                    data.events.forEach(e => {
                        if(["CONSTRUCTION","SPECIAL_EVENT","INCIDENT"].includes(e.event_type)){
                            placeEventMarker(e);
                        }
                    });
                }
            })
            .catch(err => console.error("Error fetching events:", err));
    }

    function placeEventMarker(event) {
        if (!event.geography || event.geography.type !== "Point") return;
        const coords = event.geography.coordinates;
        if (!Array.isArray(coords) || coords.length<2) return;

        const position = { lat: coords[1], lng: coords[0] };

        let iconUrl;
        switch(event.event_type){
            case "CONSTRUCTION":  iconUrl="images/construction.png"; break;
            case "SPECIAL_EVENT": iconUrl="images/special_event.png"; break;
            case "INCIDENT":      iconUrl="images/incident.png"; break;
            default: return;
        }

        const marker = new google.maps.Marker({
            position,
            map,
            icon: {
                url: iconUrl,
                scaledSize: new google.maps.Size(32,32)
            },
            title: event.headline || event.event_type || "Open511 Event"
        });

        const infoWindowContent = buildInfoWindowContent(event);
        const infoWindow = new google.maps.InfoWindow({ content: infoWindowContent });
        marker.addListener("click", () => infoWindow.open({ anchor: marker, map }));
    }

    function buildInfoWindowContent(event){
        const headline    = event.headline     || "(No Headline)";
        const description = event.description  || "(No Description)";
        const severity    = event.severity     || "(No Severity)";
        const status      = event.status       || "(No Status)";
        const createdDate = event.created      || "(No Created Date)";
        const updatedDate = event.updated      || "(No Updated Date)";

        return `
          <div style="min-width:250px">
            <h3>${headline} (${event.event_type})</h3>
            <p><strong>Description:</strong> ${description}</p>
            <p><strong>Severity:</strong> ${severity}</p>
            <p><strong>Status:</strong> ${status}</p>
            <p><strong>Created:</strong> ${createdDate}</p>
            <p><strong>Updated:</strong> ${updatedDate}</p>
          </div>
        `;
    }
</script>

</body>
</html>


